---
title: "Building Proof of Twitter using ZK Email"
date: 2024-01-15T22:12:03.284Z
type: Post
draft: false
slug: "twitter"
category: "10 min read"
tags: ["intro"]
description: "This tutorial guides you through creating a Twitter circom circuit using ZK Email's libraries."
aliases:
  - /posts/zkemail
  - /zkemail
  - /posts/tutorial
  - /tutorial
---

## Introduction

Emails serve as our gateway to various online services and platforms. ZK Email uses zk proofs to authenticate these interactions on chain while preserving privacy.

 This guide will walk you through setting up a circuit that enables you to verify your Twitter username on-chain, without disclosing any information beyond the username itself. This process uses ZK Email libraries and regex verification to ensure the authenticity and privacy of your Twitter username, allowing you to mint an NFT upon completion.

 ## Experience it Yourself

 Before diving into the technical details, we encourage you to experience Proof of Twitter firsthand. Visit [https://twitter.prove.email/](https://twitter.prove.email/) to interact with a user-friendly interface that showcases the functionality of this technology. This hands-on experience will provide you with a practical understanding of the concepts we'll explore in this guide, making the process of building your own circuit more intuitive.

<p align="center">
<img src="/proofOfTwitterUI.png" width="750"/>
</p>

## ZK Email Library

The ZK Email library contains 3 packages. 

- **zk-email/helpers** - helper functions to help generate and verify the inputs of the circuit

- **zk-email/contracts** - contains the DKIM Registry for public domains (google, yahoo, etc)

- **zk-email/circuits** - circuit templates that are used in creating your circuit

## Setting up the Repository

Create a new folder and initiate your repository:

```
yarn init -y
```

Install all three packages by running:

```bash
yarn add @zk-email/circuits @zk-email/helpers @zk-email/contracts
```

## Preparing the Email from Twitter Containing the Username

To verify ownership of a Twitter account, we will use the "Forgot your password" email from Twitter. This email inherently includes the username and can be generated at any time. By authenticating this email, we can confirm that the user has control over the corresponding Twitter account.


Let's start by obtaining the raw email file:

1. Initiate a password reset process on Twitter to send yourself a reset email.

2. Locate the email from Twitter in your inbox and download its headers. If you're using gmail you can find this option under a menu represented by three dots, then select 'Download Message'. You can also do 'Show Original' then 'Copy to Clipboard'.

<p align="center">
<img src="/emaildots.png" width="300"/>
</p>

<div style={{marginLeft: '25px'}}>
For different email clients, the process varies slightly:

### Outlook
If you're using Outlook, switch to plain text mode. Then, copy and paste the 'full email details' into the textbox on the client-side webpage.

### Gmail and Yahoo
For Gmail and Yahoo users, select 'Download Original Message', then copy and paste the contents into the textbox.
</div>

3. Finally, copy and paste the entire contents of the file into your .eml file.


## Generating regex circom for your email inputs

Now, let's use zkregex to  match the string in your forgot password email "email was meant for @{username}" and compile it into the corresponding circom file.

### 1. Install the following dependencies 

```
yarn add @zk-email/zk-regex-circom
```

### 2. Create a twitter-reset.json file at ./twitter-reset.json and insert json object inside it

```json
{
    "parts": [
        {
            "is_public": false,
            "regex_def": "email was meant for @"
        },
        {
            "is_public": true,
            "regex_def": "(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|0|1|2|3|4|5|6|7|8|9|_)+"
        }
    ]
}

```

This file takes a string preselector "email was meant for @" as private and the twitter username substring as public, since that is what we want to reveal.

### 3. Generate the circom file

Run the following command to generate the Circom file:

```
zk-regex decomposed -d ./twitter-reset.json. -c ./twitter-reset.circom -t TwitterResetRegex -g true
```

 It outputs a circom file at `./twitter-reset.circom` that has a TwitterResetRegex template.


We will integrate the regex circuit generated into our primary circuit. This will allow us to demonstrate that a user possesses an email authenticated by Twitter's private key. We can verify the presence of a string in the email body that corresponds to the user's Twitter handle and publicly disclose the username as part of the proof.

## Constructing Your Twitter Circom File

Create a file named `twitter.circom` and copy and paste this code into it.

```

pragma circom 2.1.5;

include "@zk-email/zk-regex-circom/circuits/common/from_addr_regex.circom";
include "@zk-email/circuits/email-verifier.circom";
include "@zk-email/circuits/utils/regex.circom";
include "./twitter-reset.circom";

/// @title TwitterVerifier
/// @notice Circuit to verify input email matches Twitter password reset email, and extract the username
/// @param maxHeadersLength Maximum length for the email header.
/// @param maxBodyLength Maximum length for the email body.
/// @param n Number of bits per chunk the RSA key is split into. Recommended to be 121.
/// @param k Number of chunks the RSA key is split into. Recommended to be 17.
/// @param exposeFrom Flag to expose the from email address (not necessary for verification). We don't expose `to` as its not always signed.
/// @input emailHeader Email headers that are signed (ones in `DKIM-Signature` header) as ASCII int[], padded as per SHA-256 block size.
/// @input emailHeaderLength Length of the email header including the SHA-256 padding.
/// @input pubkey RSA public key split into k chunks of n bits each.
/// @input signature RSA signature split into k chunks of n bits each.
/// @input emailBody Email body after the precomputed SHA as ASCII int[], padded as per SHA-256 block size.
/// @input emailBodyLength Length of the email body including the SHA-256 padding.
/// @input bodyHashIndex Index of the body hash `bh` in the emailHeader.
/// @input precomputedSHA Precomputed SHA-256 hash of the email body till the bodyHashIndex.
/// @input twitterUsernameIndex Index of the Twitter username in the email body.
/// @input address ETH address as identity commitment (to make it as part of the proof).
/// @output pubkeyHash Poseidon hash of the pubkey - Poseidon(n/2)(n/2 chunks of pubkey with k*2 bits per chunk).
template TwitterVerifier(maxHeadersLength, maxBodyLength, n, k, exposeFrom) {
    assert(exposeFrom < 2);

    signal input emailHeader[maxHeadersLength];
    signal input emailHeaderLength;
    signal input pubkey[k];
    signal input signature[k];
    signal input emailBody[maxBodyLength];
    signal input emailBodyLength;
    signal input bodyHashIndex;
    signal input precomputedSHA[32];
    signal input twitterUsernameIndex;
    signal input address; // we don't need to constrain the + 1 due to https://geometry.xyz/notebook/groth16-malleability


    signal output pubkeyHash;
    signal output twitterUsername;


    component EV = EmailVerifier(maxHeadersLength, maxBodyLength, n, k, 0);
    EV.emailHeader <== emailHeader;
    EV.pubkey <== pubkey;
    EV.signature <== signature;
    EV.emailHeaderLength <== emailHeaderLength;
    EV.bodyHashIndex <== bodyHashIndex;
    EV.precomputedSHA <== precomputedSHA;
    EV.emailBody <== emailBody;
    EV.emailBodyLength <== emailBodyLength;

    pubkeyHash <== EV.pubkeyHash;


    // FROM HEADER REGEX: 736,553 constraints
    if (exposeFrom) {
        signal input fromEmailIndex;

        signal (fromEmailFound, fromEmailReveal[maxHeadersLength]) <== FromAddrRegex(maxHeadersLength)(emailHeader);
        fromEmailFound === 1;

        var maxEmailLength = 255;

        signal output fromEmailAddrPacks[9] <== PackRegexReveal(maxHeadersLength, maxEmailLength)(fromEmailReveal, fromEmailIndex);
    }


    // TWITTER REGEX: 328,044 constraints
    // This computes the regex states on each character in the email body. For other apps, this is the
    // section that you want to swap out via using the zk-regex library.
    signal (twitterFound, twitterReveal[maxBodyLength]) <== TwitterResetRegex(maxBodyLength)(emailBody);
    twitterFound === 1;

    // Pack the username to int
    var maxTwitterUsernameLength = 21;
    signal twitterUsernamePacks[1] <== PackRegexReveal(maxBodyLength, maxTwitterUsernameLength)(twitterReveal, twitterUsernameIndex);
   
    // Username will fit in one field element, so we take the first item from the packed array.
    twitterUsername <== twitterUsernamePacks[0];
}


component main { public [ address ] } = TwitterVerifier(1024, 1536, 121, 17, 0);

```

There is a lot going on in this file, but we can break it down to make it easier to digest:

1. **Inputs and Outputs**: The circuit takes several inputs, including the email header, email body, RSA public key, and signature. The outputs are the `pubkeyHash` and `twitterUsername`.

2. **Email Verifier Component**: The `EmailVerifier` component is instantiated with the provided parameters and assigned the relevant inputs. This component verifies the email's authenticity using the DKIM signature.

3. **Optional From Header Regex**: If `exposeFrom` is true, the circuit will reveal the "from" email address using the `FromAddrRegex` component. Otherwise, this part is skipped.

4. **Twitter Username Regex**: The `TwitterResetRegex` template, generated earlier, is used to find the Twitter username in the email body. If the username is found, it is packed into an integer and output as `twitterUsername`.


## Generating chunked zkeys, verification key and solidity verifier

After setting up your Twitter circuit, the next step is to compile it and generate the verification key (vkey) and the zk-SNARK proving keys (zkeys). We'll create the solidity verifier as well.

To compile the circuit locally, you need to have Rust and Circom installed first. You can visit this link to install both: https://docs.circom.io/getting-started/installation/#installing-dependencies

Run this command to compile your circuit:

```
circom -l node_modules TwitterVerifier.circom -o --r1cs --wasm --sym --c
```

This process will generate a `r1cs` file, a `wasm` file, and a `sym` file. These files are essential for generating the vkey, zkey, and computing the witness.

Next create a `dev-setup.ts` file and copy and paste the following script inside.

```typescript
/**
 *
 * This script is for generating zKey and Verification Key for the circuit.
 * Running this will download the phase1 file (if not already present),
 * generate the zKey, and also export solidity and json verification keys.
 *
 * Running this will overwrite any existing zKey and verification key files.
 *
 */

// @ts-ignore
import { zKey } from "snarkjs";
import https from "https";
import fs from "fs";
import path from "path";
import pako from "pako";

// ENV Variables
let { ZKEY_ENTROPY, ZKEY_BEACON, SILENT } = process.env;
if (ZKEY_ENTROPY == null) {
  log("No entropy provided, using `dev`");
  ZKEY_ENTROPY = "dev";
}
if (ZKEY_BEACON == null) {
  ZKEY_BEACON =
    "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
  log("No ZKEY_BEACON provided, using default");
}

// Constants
const CIRCUIT_NAME = "twitter";
const BUILD_DIR = path.join(__dirname, "../build");
const PHASE1_URL =
  "https://storage.googleapis.com/zkevm/ptau/powersOfTau28_hez_final_22.ptau";
const PHASE1_PATH = path.join(BUILD_DIR, "powersOfTau28_hez_final_22.ptau");
const ARTIFACTS_DIR = path.join(BUILD_DIR, 'artifacts');
const SOLIDITY_TEMPLATE = path.join(
  require.resolve("snarkjs"),
  "../../templates/verifier_groth16.sol.ejs"
);
const SOLIDITY_VERIFIER_PATH = path.join(
  __dirname,
  "../../contracts/src/Verifier.sol"
);

function log(...message: any) {
  if (!SILENT) {
    console.log(...message);
  }
}

async function downloadPhase1() {
  if (!fs.existsSync(PHASE1_PATH)) {
    log(`✘ Phase 1 not found at ${PHASE1_PATH}`);
    log(`䷢ Downloading Phase 1`);

    const phase1File = fs.createWriteStream(PHASE1_PATH);

    return new Promise((resolve, reject) => {
      https
        .get(PHASE1_URL, (response) => {
          response.pipe(phase1File);
          phase1File.on("finish", () => {
            phase1File.close();
            resolve(true);
          });
        })
        .on("error", (err) => {
          fs.unlink(PHASE1_PATH, () => {});
          reject(err);
        });
    });
  }
}

async function generateKeys(
  phase1Path: string,
  r1cPath: string,
  zKeyPath: string,
  vKeyPath: string,
  solidityVerifierPath: string
) {
  await zKey.newZKey(r1cPath, phase1Path, zKeyPath + ".step1", console);
  log("✓ Partial ZKey generated");

  await zKey.contribute(
    zKeyPath + ".step1",
    zKeyPath + ".step2",
    "Contributer 1",
    ZKEY_ENTROPY,
    console
  );
  log("✓ First contribution completed");

  await zKey.beacon(
    zKeyPath + ".step2",
    zKeyPath,
    "Final Beacon",
    ZKEY_BEACON,
    10,
    console
  );
  log("✓ Beacon applied");

  // Verification key
  const vKey = await zKey.exportVerificationKey(zKeyPath, console);
  fs.writeFileSync(vKeyPath, JSON.stringify(vKey, null, 2));
  log(`✓ Verification key exported - ${vKeyPath}`);

  // Solidity verifier
  const templates = {
    groth16: fs.readFileSync(SOLIDITY_TEMPLATE, "utf8"),
  };
  const code = await zKey.exportSolidityVerifier(zKeyPath, templates, console);
  fs.writeFileSync(solidityVerifierPath, code);
  log(`✓ Solidity verifier exported - ${solidityVerifierPath}`);

  // Cleanup
  ["", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k"].forEach((suffix) => {
    if (fs.existsSync(zKeyPath + ".step1" + suffix))
      fs.unlinkSync(zKeyPath + ".step1" + suffix);
    if (fs.existsSync(zKeyPath + ".step2" + suffix))
      fs.unlinkSync(zKeyPath + ".step2" + suffix);
  });
}

async function exec() {
  await downloadPhase1();
  log("✓ Phase 1:", PHASE1_PATH);

  const circuitPath = path.join(BUILD_DIR, `${CIRCUIT_NAME}.r1cs`);
  if (!fs.existsSync(circuitPath)) {
    throw new Error(`${circuitPath} does not exist.`);
  }

  // Create artifacts directory and copy build files
  fs.mkdirSync(path.join(BUILD_DIR, 'artifacts'), { recursive: true });

  fs.copyFileSync(
    path.join(BUILD_DIR, `${CIRCUIT_NAME}.r1cs`),
    path.join(ARTIFACTS_DIR, `${CIRCUIT_NAME}.r1cs`)
  );
  fs.copyFileSync(
    path.join(BUILD_DIR, `${CIRCUIT_NAME}_js/${CIRCUIT_NAME}.wasm`),
    path.join(ARTIFACTS_DIR, `${CIRCUIT_NAME}.wasm`)
  );
  
  const zKeyPath = path.join(BUILD_DIR, `${CIRCUIT_NAME}.zkey`);

  await generateKeys(
    PHASE1_PATH,
    circuitPath,
    zKeyPath,
    path.join(ARTIFACTS_DIR, `${CIRCUIT_NAME}.vkey.json`),
    SOLIDITY_VERIFIER_PATH
  );
  log("✓ zkey, vkey and Solidity verifier generated");

  // Compress zkeys and copy to artifacts directory
  ["", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k"].forEach((suffix) => {
    fs.writeFileSync(
      path.join(ARTIFACTS_DIR, `${CIRCUIT_NAME}.zkey`) + suffix + '.gz',
      pako.gzip(fs.readFileSync(zKeyPath + suffix))
    );
  });

  log(`✓ All artifacts saved to ${ARTIFACTS_DIR} directory`);
}

exec()
  .then(() => {
    process.exit(0);
  })
  .catch((err) => {
    console.log("Error: ", err);
    process.exit(1);
  });
```

This script generates the chunked zkeys, verification_key.json, and verifier.sol in the artifacts directory. The zkey is divided into chunks to optimize in-browser proving times, as the twitter.circom file is quite large.

To begin, install this specific version of snarkjs which supports chunked key verification.

```
yarn add snarkjs@git+https://github.com/vb7401/snarkjs.git#24981febe8826b6ab76ae4d76cf7f9142919d2b8
```

Then you need to download the `powersOfTau28_hez_final_22.ptau` file from the provided URL and place it in the build directory.

```
wget https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28hez_final22.ptau
```
Next run this command in your terminal:

```
ZKEY_ENTROPY=<random-number> ZKEY_BEACON=<random-hex> ts-node dev-setup.ts
```

## Generating inputs and proof

After setting up the main Twitter verification circuit, we can proceed to generate the inputs and proofs for your circuit using the ZK Email helpers SDK.

You can create a `inputs.ts` file and place this code inside:
``` typescript
import { bytesToBigInt, fromHex } from "@zk-email/helpers/dist/binaryFormat";
import { generateEmailVerifierInputs } from "@zk-email/helpers/dist/input-generators";

export const STRING_PRESELECTOR = "email was meant for @";

export type ITwitterCircuitInputs = {
  twitterUsernameIndex: string;
  address: string;
  emailHeader: string[];
  emailHeaderLength: string;
  pubkey: string[];
  signature: string[];
  emailBody?: string[] | undefined;
  emailBodyLength?: string | undefined;
  precomputedSHA?: string[] | undefined;
  bodyHashIndex?: string | undefined;
};

export async function generateTwitterVerifierCircuitInputs(
  email: string | Buffer,
  ethereumAddress: string
): Promise<ITwitterCircuitInputs> {
  const emailVerifierInputs = await generateEmailVerifierInputs(email, {
    shaPrecomputeSelector: STRING_PRESELECTOR,
  });

  const bodyRemaining = emailVerifierInputs.emailBody!.map((c) => Number(c)); // Char array to Uint8Array
  const selectorBuffer = Buffer.from(STRING_PRESELECTOR);
  const usernameIndex =
    Buffer.from(bodyRemaining).indexOf(selectorBuffer) + selectorBuffer.length;

  const address = bytesToBigInt(fromHex(ethereumAddress)).toString();

  return {
    ...emailVerifierInputs,
    twitterUsernameIndex: usernameIndex.toString(),
    address,
  };
}

```

Next make a file called `generate-proof.ts` and copy and paste this code inside.

```
import { program } from "commander";
import fs from "fs";
import path from "path";
import { generateTwitterVerifierCircuitInputs } from "../helpers/inputs";
const snarkjs = require("snarkjs");

program
  .requiredOption("--email-file <string>", "Path to email file")
  .requiredOption(
    "--ethereum-address <string>",
    "Ethereum address to verify twitter handle against"
  )
  .option("--silent", "No console logs");

program.parse();
const args = program.opts();

const CIRCUIT_NAME = "twitter";
const BUILD_DIR = path.join(__dirname, "../build");
const OUTPUT_DIR = path.join(__dirname, "../proofs");

function log(...message: any) {
  if (!args.silent) {
    console.log(...message);
  }
}
const logger = { log, error: log, warn: log, debug: log };

async function generate() {
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR);
  }

  if (!fs.existsSync(args.emailFile)) {
    throw new Error("--input file path arg must end with .json");
  }

  log("Generating input and proof for:", args.emailFile);

  const rawEmail = Buffer.from(fs.readFileSync(args.emailFile, "utf8"));
  const circuitInputs = await generateTwitterVerifierCircuitInputs(rawEmail, args.ethereumAddress);

  log("\n\nGenerated Inputs:", circuitInputs, "\n\n");

  fs.writeFileSync(
    path.join(OUTPUT_DIR, "input.json"),
    JSON.stringify(circuitInputs, null, 2)
  );
  log("Inputs written to", path.join(OUTPUT_DIR, "input.json"));

  // Generate witness
  const wasm = fs.readFileSync(
    path.join(BUILD_DIR, `${CIRCUIT_NAME}_js/${CIRCUIT_NAME}.wasm`)
  );
  const wc = require(path.join(
    BUILD_DIR,
    `${CIRCUIT_NAME}_js/witness_calculator.js`
  ));
  const witnessCalculator = await wc(wasm);
  const buff = await witnessCalculator.calculateWTNSBin(circuitInputs, 0);
  fs.writeFileSync(path.join(OUTPUT_DIR, `input.wtns`), buff);

  // Generate proof
  const { proof, publicSignals } = await snarkjs.groth16.prove(
    path.join(BUILD_DIR, `${CIRCUIT_NAME}.zkey`),
    path.join(OUTPUT_DIR, `input.wtns`),
    logger
  );

  fs.writeFileSync(
    path.join(OUTPUT_DIR, "proof.json"),
    JSON.stringify(proof, null, 2)
  );
  log("Proof written to", path.join(OUTPUT_DIR, "proof.json"));

  fs.writeFileSync(
    path.join(OUTPUT_DIR, "public.json"),
    JSON.stringify(publicSignals, null, 2)
  );
  log("Public Inputs written to", path.join(OUTPUT_DIR, "public.json"));

  const vkey = JSON.parse(fs.readFileSync(path.join(BUILD_DIR, `/artifacts/twitter.vkey.json`)).toString());
  const proofVerified = await snarkjs.groth16.verify(
    vkey,
    publicSignals,
    proof
  );
  if (proofVerified) {
    console.log("Proof Verified");
  } else {
    throw new Error("Proof Verification Failed");
  }

  process.exit(0);
}

generate().catch((err) => {
  console.error("Error generating proof", err);
  process.exit(1);
});
```
To run this script copy and paste this into your terminal:

```bash
ts-node generate-proof.ts --email-file ../tests/emls/twitter-test.eml --ethereum-address <your-eth-address>
```
*Note*: Remember to replace the address and the path to the raw email file with your own information.

This script imports the `generateTwitterVerifierCircuitInputs` from the inputs.ts file and it will  save    `inputs.json`, `input.wtns`, `proof.json`, and `public.json` in the proof directory.


## Contracts
The `ProofOfTwitter.sol` contract includes the required on-chain logic for verifying Twitter accounts. When the proof is validated successfully, an NFT is minted on the blockchain.


The contract begins by importing two crucial files: `Dkimregistry.sol` and `Verifier.sol`.

```solidity
    import { Verifier } from "./Verifier.sol";
    import "@zk-email/contracts/DKIMRegistry.sol";
```

`Dkimregistry.sol` maintains a registry of public domains. This registry is used to cross-verify the domain from which the email originated in the proof.

`Verifier.sol` contract is responsible for validating the proof.


It then defines constants that represent the indices of various public signals within the proof, such as the DKIM public key hash, the Twitter username, and the Ethereum address. These constants are used to retrieve the corresponding values from the signals array during verification.

```solidity
    uint32 public constant pubKeyHashIndexInSignals = 0; // index of DKIM public key hash in signals array

    uint32 public constant usernameIndexInSignals = 1; // index of first packed twitter username in signals array

    uint32 public constant usernameLengthInSignals = 1; // length of packed twitter username in signals array
    
    uint32 public constant addressIndexInSignals = 2; // index of ethereum address in signals array
```

The contract includes a function to verify the DKIM public key hash against a registry to ensure the email's authenticity:

```solidity
    bytes32 dkimPublicKeyHashInCircuit = bytes32(signals[pubKeyHashIndexInSignals]);
    require(dkimRegistry.isDKIMPublicKeyHashValid(domain, dkimPublicKeyHashInCircuit), "invalid dkim signature");
```

It also contains a function that uses the `verifier` contract to check the validity of the provided proof:

```solidity
    require(
        verifier.verifyProof(
            [proof[0], proof[1]],
            [[proof[2], proof[3]], [proof[4], proof[5]]],
            [proof[6], proof[7]],
            signals
        ),
        "Invalid Proof"
    );
```

Additionally, the contract includes logic to extract the Twitter username from the packed signals array. Although currently, a Twitter username can fit within a single signal, the code is designed to handle longer usernames that may span multiple signals:

```solidity
    uint256[] memory usernamePack = new uint256[](usernameLengthInSignals);
    for (uint256 i = usernameIndexInSignals; i < (usernameIndexInSignals + usernameLengthInSignals); i++) {
        usernamePack[i - usernameIndexInSignals] = signals[i];
    }
```

Understanding these components is essential for anyone looking to build a system that leverages this contract for Twitter account verification using zk-SNARKs. The full contract code is available at the GitHub repository:
[ProofOfTwitter.sol](https://github.com/zkemail/proof-of-twitter/blob/main/packages/contracts/src/ProofOfTwitter.sol)



## Conclusion

This guide provided just one example of a circuit you can build. For more examples and resources, you can check out the [zk-email verifier usage guide](https://zkemail.gitbook.io/zk-email/zk-email-verifier/usage-guide) and the [Twitter Circuit Code](https://github.com/zkemail/zk-email-verify/blob/main/packages/twitter-verifier-circuits/twitter.circom).

This is just the beginning of verifiable provenance data. As you continue to explore and build, you'll discover the vast potential of this technology. The power of zk-SNARKs allows for the creation of systems where data can be verified without revealing any additional information. This opens up a world of possibilities for privacy-preserving applications.

